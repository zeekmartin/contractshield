# Vulnerability Checks

Date: 2026-01-17

ContractShield includes a set of vulnerability checks that run **before** contract validation. These checks detect common attack patterns in request payloads.

## Architecture

```
RequestContext
     │
     ▼
┌─────────────────────────┐
│ 1. Vulnerability checks │  ← Denylist (attack patterns)
└─────────────────────────┘
     │
     ▼
┌─────────────────────────┐
│ 2. Limits               │  ← Allowlist (contract-first)
│ 3. Contract validation  │
│ 4. Webhook checks       │
│ 5. CEL invariants       │
└─────────────────────────┘
```

## Available Checks

| Check | Default | Severity | Description |
|-------|---------|----------|-------------|
| `prototypePollution` | **ON** | critical | Detects `__proto__`, `constructor`, `prototype` keys |
| `pathTraversal` | **ON** | high | Detects `../` patterns and encoded variants |
| `ssrfInternal` | **ON** | critical | Detects internal IPs, localhost, cloud metadata endpoints |
| `nosqlInjection` | OFF | critical | Detects MongoDB operators (`$gt`, `$where`, etc.) |
| `commandInjection` | OFF | critical | Detects shell metacharacters (`;`, `|`, backticks) |

## Configuration

### Global defaults

Configure vulnerability checks in `defaults.vulnerabilityChecks`:

```yaml
policyVersion: "0.1"
defaults:
  vulnerabilityChecks:
    prototypePollution: true   # Default: true
    pathTraversal: true        # Default: true
    ssrfInternal: true         # Default: true
    nosqlInjection: false      # Default: false (opt-in)
    commandInjection: false    # Default: false (opt-in)
routes:
  # ...
```

### Per-route overrides

Override global settings for specific routes:

```yaml
routes:
  - id: upload.file
    match:
      method: POST
      path: /api/upload
    vulnerability:
      pathTraversal:
        fields: ["filename", "path"]  # Only check these fields
      commandInjection: false          # Disable for this route
```

### Field targeting

For checks that support it, you can target specific fields instead of scanning all strings:

```yaml
defaults:
  vulnerabilityChecks:
    ssrfInternal:
      fields: ["callbackUrl", "webhookUrl", "imageUrl"]
    pathTraversal:
      fields: ["filename", "filePath", "directory"]
```

## Check Details

### Prototype Pollution

Scans all JSON keys recursively for dangerous property names that could pollute `Object.prototype`:

**Detected patterns:**
- `__proto__`
- `constructor`
- `prototype`

**Example attack:**
```json
{
  "__proto__": {
    "isAdmin": true
  }
}
```

**Rule hit:** `vulnerability.prototypePollution`

### Path Traversal

Detects directory traversal patterns in string values:

**Detected patterns:**
- `../` and `..\`
- URL encoded: `%2e%2e%2f`, `%2e%2e/`
- Double encoded: `%252e%252e%252f`
- Unicode variants
- Null bytes: `%00`

**Example attack:**
```json
{
  "filename": "../../../etc/passwd"
}
```

**Rule hit:** `vulnerability.pathTraversal`

### SSRF Internal

Detects URLs pointing to internal resources:

**Detected hostnames:**
- `localhost`, `127.0.0.1`, `0.0.0.0`
- Private IPs: `10.*`, `172.16-31.*`, `192.168.*`
- Link-local: `169.254.*`
- Cloud metadata: `169.254.169.254`

**Detected protocols:**
- `file://`, `gopher://`, `dict://`, `ftp://`, `ldap://`

**Example attack:**
```json
{
  "callbackUrl": "http://169.254.169.254/latest/meta-data/"
}
```

**Rule hit:** `vulnerability.ssrfInternal`

### NoSQL Injection (opt-in)

Detects MongoDB query operators in JSON keys:

**Detected operators:**
- Comparison: `$eq`, `$gt`, `$gte`, `$lt`, `$lte`, `$ne`, `$in`, `$nin`
- Logical: `$and`, `$or`, `$not`, `$nor`
- Evaluation: `$where`, `$regex`, `$expr`
- And many more...

**Example attack:**
```json
{
  "password": { "$gt": "" }
}
```

**Rule hit:** `vulnerability.nosqlInjection`

**Note:** This check is opt-in because `$` prefixed keys are sometimes used legitimately (e.g., MongoDB updates).

### Command Injection (opt-in)

Detects shell metacharacters that could lead to command injection:

**Detected patterns (high confidence):**
- `; command`
- `| command`
- `` `command` ``
- `$(command)`
- `&& command`
- `|| command`

**Example attack:**
```json
{
  "filename": "test.txt; rm -rf /"
}
```

**Rule hit:** `vulnerability.commandInjection`

**Note:** This check is opt-in and uses high-confidence patterns by default to minimize false positives. For sensitive fields, enable it with field targeting:

```yaml
vulnerability:
  commandInjection:
    fields: ["command", "exec", "script"]
```

## Tuning False Positives

### Path Traversal

URLs with `..` in query parameters may trigger false positives:
```
https://example.com/api?ref=../path
```

**Solution:** Target specific fields instead of scanning all strings:
```yaml
pathTraversal:
  fields: ["filename", "path"]
```

### SSRF Internal

Some applications legitimately need to call internal services.

**Solution:** Disable for specific routes:
```yaml
routes:
  - id: internal.proxy
    vulnerability:
      ssrfInternal: false
```

### Command Injection

Many strings contain `;` or `|` without being attacks.

**Solution:** Only enable for known dangerous fields:
```yaml
commandInjection:
  fields: ["shellCommand", "script"]
```

## Performance

All vulnerability checks are designed to be fast:

- No external dependencies
- No regex catastrophic backtracking
- Early exit on first violation (for single-hit checks)
- Typical execution: < 1ms per request

## Best Practices

1. **Keep defaults ON** for `prototypePollution`, `pathTraversal`, `ssrfInternal`
2. **Enable opt-in checks** only where needed (NoSQL, Command Injection)
3. **Use field targeting** to reduce false positives
4. **Monitor mode first** when adding new checks to observe behavior
5. **Test with golden fixtures** before deploying changes
