"""Main vulnerability scanner that orchestrates all checks."""

from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Protocol, Union

from contractshield.core.result import RuleHit, Severity


class VulnerabilityType(str, Enum):
    """Types of vulnerabilities detected."""

    SQLI = "sql_injection"
    XSS = "cross_site_scripting"
    PATH_TRAVERSAL = "path_traversal"
    PROTOTYPE_POLLUTION = "prototype_pollution"
    SSRF_INTERNAL = "ssrf_internal"
    NOSQL_INJECTION = "nosql_injection"
    COMMAND_INJECTION = "command_injection"


@dataclass
class VulnerabilityFinding:
    """Represents a detected vulnerability."""

    type: VulnerabilityType
    severity: Severity
    path: str  # JSON path where found
    value: str  # The suspicious value (truncated)
    message: str

    def to_rule_hit(self, rule_id_prefix: str = "vulnerability") -> RuleHit:
        """Convert to RuleHit for decision making."""
        return RuleHit(
            id=f"{rule_id_prefix}.{self.type.value}",
            severity=self.severity,
            message=self.message,
            path=self.path,
            value=self.value[:100] if len(self.value) > 100 else self.value,
        )


class VulnerabilityChecker(Protocol):
    """Protocol for vulnerability checkers."""

    def check(
        self, value: Any, path: str, fields: Optional[List[str]] = None
    ) -> List[VulnerabilityFinding]:
        """Check a value for vulnerabilities."""
        ...


class VulnerabilityScanner:
    """
    Main vulnerability scanner that orchestrates all checks.

    This is the first layer of protection, running before contract validation.
    It recursively scans request data for common vulnerability patterns.
    """

    def __init__(
        self,
        enable_sqli: bool = True,
        enable_xss: bool = True,
        enable_path_traversal: Union[bool, Dict[str, Any]] = True,
        enable_ssrf: Union[bool, Dict[str, Any]] = True,
        enable_prototype_pollution: bool = True,
        enable_nosql_injection: bool = False,  # Opt-in
        enable_command_injection: Union[bool, Dict[str, Any]] = False,  # Opt-in
    ):
        self.checkers: List[tuple[VulnerabilityChecker, Optional[List[str]]]] = []

        # Import checkers here to avoid circular imports
        from .sqli import SQLiChecker
        from .xss import XSSChecker
        from .path_traversal import PathTraversalChecker
        from .ssrf import SSRFChecker
        from .prototype import PrototypePollutionChecker
        from .nosql import NoSQLInjectionChecker
        from .command import CommandInjectionChecker

        if enable_sqli:
            self.checkers.append((SQLiChecker(), None))

        if enable_xss:
            self.checkers.append((XSSChecker(), None))

        if enable_path_traversal:
            fields = None
            if isinstance(enable_path_traversal, dict):
                fields = enable_path_traversal.get("fields")
            self.checkers.append((PathTraversalChecker(), fields))

        if enable_ssrf:
            fields = None
            if isinstance(enable_ssrf, dict):
                fields = enable_ssrf.get("fields")
            self.checkers.append((SSRFChecker(), fields))

        if enable_prototype_pollution:
            self.checkers.append((PrototypePollutionChecker(), None))

        if enable_nosql_injection:
            self.checkers.append((NoSQLInjectionChecker(), None))

        if enable_command_injection:
            fields = None
            if isinstance(enable_command_injection, dict):
                fields = enable_command_injection.get("fields")
            self.checkers.append((CommandInjectionChecker(), fields))

    def scan(
        self, data: Any, path: str = "$", max_depth: int = 50
    ) -> List[VulnerabilityFinding]:
        """
        Recursively scan data for vulnerabilities.

        Args:
            data: The data to scan (dict, list, or primitive)
            path: Current JSON path for reporting
            max_depth: Maximum recursion depth

        Returns:
            List of vulnerability findings
        """
        findings: List[VulnerabilityFinding] = []

        if max_depth <= 0:
            return findings

        self._scan_recursive(data, path, findings, max_depth)
        return findings

    def _scan_recursive(
        self,
        data: Any,
        path: str,
        findings: List[VulnerabilityFinding],
        remaining_depth: int,
    ) -> None:
        """Recursively scan data structure."""
        if remaining_depth <= 0:
            return

        if isinstance(data, dict):
            for key, value in data.items():
                current_path = f"{path}.{key}"

                # Check the key itself (for prototype pollution)
                for checker, fields in self.checkers:
                    if fields is None or self._path_matches_fields(current_path, fields):
                        key_findings = checker.check(key, f"{path}[key:{key}]", fields)
                        findings.extend(key_findings)

                # Check the value
                self._scan_recursive(value, current_path, findings, remaining_depth - 1)

        elif isinstance(data, list):
            for i, item in enumerate(data):
                current_path = f"{path}[{i}]"
                self._scan_recursive(item, current_path, findings, remaining_depth - 1)

        elif isinstance(data, str):
            # Run all checkers on string values
            for checker, fields in self.checkers:
                if fields is None or self._path_matches_fields(path, fields):
                    string_findings = checker.check(data, path, fields)
                    findings.extend(string_findings)

    def _path_matches_fields(self, path: str, fields: List[str]) -> bool:
        """Check if path matches any of the specified fields."""
        for field in fields:
            if path.endswith(f".{field}") or f".{field}." in path:
                return True
        return False


def truncate_value(value: str, max_length: int = 100) -> str:
    """Truncate value for safe logging."""
    if len(value) > max_length:
        return value[:max_length] + "..."
    return value
