"""Path Traversal detection."""

import re
from typing import Any, List, Optional
from urllib.parse import unquote

from contractshield.core.result import Severity

from .scanner import VulnerabilityFinding, VulnerabilityType, truncate_value


class PathTraversalChecker:
    """
    Path Traversal vulnerability checker.

    Detects attempts to traverse directory structures using various
    encoding techniques.
    """

    # Basic patterns
    BASIC_PATTERNS = [
        re.compile(r"\.\.\/"),  # ../
        re.compile(r"\.\.\\"),  # ..\
        re.compile(r"\.\.%2f", re.IGNORECASE),  # ..%2f (URL encoded /)
        re.compile(r"\.\.%5c", re.IGNORECASE),  # ..%5c (URL encoded \)
        re.compile(r"%2e%2e%2f", re.IGNORECASE),  # %2e%2e%2f (full URL encoded ../)
        re.compile(r"%2e%2e/", re.IGNORECASE),  # %2e%2e/ (encoded dots)
        re.compile(r"\.%2e/", re.IGNORECASE),  # .%2e/ (partial encoding)
        re.compile(r"%2e\./", re.IGNORECASE),  # %2e./ (partial encoding)
    ]

    # Double encoding patterns
    DOUBLE_ENCODED_PATTERNS = [
        re.compile(r"%252e%252e%252f", re.IGNORECASE),  # Double encoded ../
        re.compile(r"%252e%252e/", re.IGNORECASE),
        re.compile(r"\.\.%252f", re.IGNORECASE),
    ]

    # Null byte patterns
    NULL_BYTE_PATTERNS = [
        re.compile(r"%00"),  # URL encoded null
        re.compile(r"\\x00"),  # Hex null
        re.compile(r"\\0"),  # Escaped null
    ]

    # Overlong UTF-8 patterns
    OVERLONG_PATTERNS = [
        re.compile(r"%c0%ae", re.IGNORECASE),  # Overlong dot
        re.compile(r"%c0%2e", re.IGNORECASE),
        re.compile(r"%e0%80%ae", re.IGNORECASE),
    ]

    # Absolute path patterns
    ABSOLUTE_PATH_PATTERNS = [
        re.compile(r"^/etc/"),
        re.compile(r"^/proc/"),
        re.compile(r"^/var/"),
        re.compile(r"^[a-zA-Z]:\\", re.IGNORECASE),  # Windows paths
        re.compile(r"\\\\[^\\]+\\"),  # UNC paths
    ]

    def check(
        self, value: Any, path: str, fields: Optional[List[str]] = None
    ) -> List[VulnerabilityFinding]:
        """Check value for path traversal patterns."""
        findings: List[VulnerabilityFinding] = []

        if not isinstance(value, str):
            return findings

        # Skip very short strings
        if len(value) < 2:
            return findings

        # Check original value
        finding = self._check_string(value, path)
        if finding:
            findings.append(finding)
            return findings

        # Also check URL-decoded version
        try:
            decoded = unquote(value)
            if decoded != value:
                finding = self._check_string(decoded, path)
                if finding:
                    findings.append(finding)
                    return findings

                # Double decode
                double_decoded = unquote(decoded)
                if double_decoded != decoded:
                    finding = self._check_string(double_decoded, path)
                    if finding:
                        findings.append(finding)
        except Exception:
            pass

        return findings

    def _check_string(self, value: str, path: str) -> Optional[VulnerabilityFinding]:
        """Check a single string for path traversal patterns."""
        # Basic patterns
        for pattern in self.BASIC_PATTERNS:
            if pattern.search(value):
                return VulnerabilityFinding(
                    type=VulnerabilityType.PATH_TRAVERSAL,
                    severity=Severity.HIGH,
                    path=path,
                    value=truncate_value(value),
                    message="Path traversal sequence detected",
                )

        # Double encoded patterns
        for pattern in self.DOUBLE_ENCODED_PATTERNS:
            if pattern.search(value):
                return VulnerabilityFinding(
                    type=VulnerabilityType.PATH_TRAVERSAL,
                    severity=Severity.CRITICAL,
                    path=path,
                    value=truncate_value(value),
                    message="Double-encoded path traversal detected",
                )

        # Null byte patterns
        for pattern in self.NULL_BYTE_PATTERNS:
            if pattern.search(value):
                return VulnerabilityFinding(
                    type=VulnerabilityType.PATH_TRAVERSAL,
                    severity=Severity.CRITICAL,
                    path=path,
                    value=truncate_value(value),
                    message="Null byte injection detected",
                )

        # Overlong UTF-8 patterns
        for pattern in self.OVERLONG_PATTERNS:
            if pattern.search(value):
                return VulnerabilityFinding(
                    type=VulnerabilityType.PATH_TRAVERSAL,
                    severity=Severity.CRITICAL,
                    path=path,
                    value=truncate_value(value),
                    message="Overlong UTF-8 encoding detected",
                )

        # Absolute paths (only for certain fields)
        for pattern in self.ABSOLUTE_PATH_PATTERNS:
            if pattern.search(value):
                return VulnerabilityFinding(
                    type=VulnerabilityType.PATH_TRAVERSAL,
                    severity=Severity.HIGH,
                    path=path,
                    value=truncate_value(value),
                    message="Absolute path reference detected",
                )

        return None
