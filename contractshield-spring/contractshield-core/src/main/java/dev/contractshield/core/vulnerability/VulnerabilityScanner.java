package dev.contractshield.core.vulnerability;

import com.fasterxml.jackson.databind.JsonNode;
import dev.contractshield.core.vulnerability.checks.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Scans request data for common security vulnerabilities.
 * <p>
 * This is Layer 1 protection that runs before contract validation.
 */
public class VulnerabilityScanner {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityScanner.class);

    private final List<VulnerabilityCheck> checks;
    private final PrototypePollutionCheck prototypePollutionCheck;
    private final int maxDepth;

    /**
     * Create scanner with default configuration.
     */
    public VulnerabilityScanner() {
        this(VulnerabilityScannerConfig.defaults());
    }

    /**
     * Create scanner with custom configuration.
     */
    public VulnerabilityScanner(VulnerabilityScannerConfig config) {
        this.checks = new ArrayList<>();
        this.maxDepth = config.getMaxDepth();

        if (config.isEnableSqli()) {
            checks.add(new SQLiCheck());
        }
        if (config.isEnableXss()) {
            checks.add(new XSSCheck());
        }
        if (config.isEnablePathTraversal()) {
            checks.add(new PathTraversalCheck());
        }

        this.prototypePollutionCheck = config.isEnablePrototypePollution()
                ? new PrototypePollutionCheck()
                : null;
    }

    /**
     * Scan JSON data for vulnerabilities.
     *
     * @param data JSON data to scan
     * @return list of findings (empty if clean)
     */
    public List<VulnerabilityFinding> scan(JsonNode data) {
        List<VulnerabilityFinding> findings = new ArrayList<>();
        scanNode(data, "$", findings, 0);
        return findings;
    }

    /**
     * Scan a map for vulnerabilities.
     *
     * @param data map data to scan
     * @return list of findings (empty if clean)
     */
    public List<VulnerabilityFinding> scan(Map<String, Object> data) {
        List<VulnerabilityFinding> findings = new ArrayList<>();
        scanMap(data, "$", findings, 0);
        return findings;
    }

    private void scanNode(JsonNode node, String path, List<VulnerabilityFinding> findings, int depth) {
        if (depth > maxDepth) {
            return;
        }

        if (node == null || node.isNull()) {
            return;
        }

        if (node.isTextual()) {
            String value = node.asText();
            scanValue(value, path, findings);
        } else if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> entry = fields.next();
                String fieldName = entry.getKey();
                String fieldPath = path + "." + fieldName;

                // Check for prototype pollution in key names
                if (prototypePollutionCheck != null && prototypePollutionCheck.isDangerousKey(fieldName)) {
                    findings.add(VulnerabilityFinding.of(
                            VulnerabilityType.PROTOTYPE_POLLUTION,
                            Severity.CRITICAL,
                            fieldPath,
                            fieldName,
                            "Prototype pollution attempt in field name"
                    ));
                }

                scanNode(entry.getValue(), fieldPath, findings, depth + 1);
            }
        } else if (node.isArray()) {
            for (int i = 0; i < node.size(); i++) {
                scanNode(node.get(i), path + "[" + i + "]", findings, depth + 1);
            }
        }
    }

    @SuppressWarnings("unchecked")
    private void scanMap(Map<String, Object> map, String path, List<VulnerabilityFinding> findings, int depth) {
        if (depth > maxDepth) {
            return;
        }

        for (Map.Entry<String, Object> entry : map.entrySet()) {
            String fieldName = entry.getKey();
            String fieldPath = path + "." + fieldName;
            Object value = entry.getValue();

            // Check for prototype pollution in key names
            if (prototypePollutionCheck != null && prototypePollutionCheck.isDangerousKey(fieldName)) {
                findings.add(VulnerabilityFinding.of(
                        VulnerabilityType.PROTOTYPE_POLLUTION,
                        Severity.CRITICAL,
                        fieldPath,
                        fieldName,
                        "Prototype pollution attempt in field name"
                ));
            }

            if (value instanceof String) {
                scanValue((String) value, fieldPath, findings);
            } else if (value instanceof Map) {
                scanMap((Map<String, Object>) value, fieldPath, findings, depth + 1);
            } else if (value instanceof List) {
                List<?> list = (List<?>) value;
                for (int i = 0; i < list.size(); i++) {
                    Object item = list.get(i);
                    String itemPath = fieldPath + "[" + i + "]";
                    if (item instanceof String) {
                        scanValue((String) item, itemPath, findings);
                    } else if (item instanceof Map) {
                        scanMap((Map<String, Object>) item, itemPath, findings, depth + 1);
                    }
                }
            }
        }
    }

    private void scanValue(String value, String path, List<VulnerabilityFinding> findings) {
        for (VulnerabilityCheck check : checks) {
            check.check(value, path).ifPresent(findings::add);
        }

        // Also check prototype pollution in value
        if (prototypePollutionCheck != null) {
            prototypePollutionCheck.check(value, path).ifPresent(findings::add);
        }
    }
}
