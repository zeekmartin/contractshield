package dev.contractshield.spring.test;

import java.util.Map;

/**
 * Test request payloads for vulnerability testing.
 * These payloads can be used to verify that ContractShield correctly
 * detects and blocks malicious inputs.
 */
public final class VulnerabilityTestRequests {

    private VulnerabilityTestRequests() {
        // Utility class
    }

    /**
     * SQL injection test payloads.
     */
    public static final class SQLi {
        /** UNION-based SQL injection payload. */
        public static final String UNION_SELECT = "' UNION SELECT * FROM users --";
        /** Boolean-based SQL injection payload. */
        public static final String OR_1_EQUALS_1 = "' OR '1'='1";
        /** Stacked query SQL injection payload. */
        public static final String SEMICOLON_DROP = "'; DROP TABLE users; --";
        /** Comment-based authentication bypass payload. */
        public static final String COMMENT_BYPASS = "admin'--";

        /**
         * Creates a payload map with the given field containing a SQL injection.
         *
         * @param field the field name to inject
         * @return map containing the malicious payload
         */
        public static Map<String, Object> payload(String field) {
            return Map.of(field, UNION_SELECT);
        }
    }

    /**
     * XSS test payloads.
     */
    public static final class XSS {
        /** Script tag XSS payload. */
        public static final String SCRIPT_ALERT = "<script>alert('xss')</script>";
        /** Image onerror XSS payload. */
        public static final String IMG_ONERROR = "<img src=x onerror=alert('xss')>";
        /** Body onload XSS payload. */
        public static final String EVENT_HANDLER = "<body onload=alert('xss')>";
        /** JavaScript URL XSS payload. */
        public static final String JAVASCRIPT_URL = "javascript:alert('xss')";

        /**
         * Creates a payload map with the given field containing an XSS attack.
         *
         * @param field the field name to inject
         * @return map containing the malicious payload
         */
        public static Map<String, Object> payload(String field) {
            return Map.of(field, SCRIPT_ALERT);
        }
    }

    /**
     * Path traversal test payloads.
     */
    public static final class PathTraversal {
        /** Unix path traversal to /etc/passwd. */
        public static final String UNIX_PASSWD = "../../../etc/passwd";
        /** Windows path traversal to hosts file. */
        public static final String WINDOWS_HOSTS = "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts";
        /** URL-encoded path traversal payload. */
        public static final String URL_ENCODED = "..%2F..%2F..%2Fetc%2Fpasswd";

        /**
         * Creates a payload map with the given field containing a path traversal.
         *
         * @param field the field name to inject
         * @return map containing the malicious payload
         */
        public static Map<String, Object> payload(String field) {
            return Map.of(field, UNIX_PASSWD);
        }
    }

    /**
     * Prototype pollution test payloads.
     */
    public static final class PrototypePollution {
        /** Proto property name. */
        public static final String PROTO = "__proto__";
        /** Constructor property name. */
        public static final String CONSTRUCTOR = "constructor";
        /** Prototype property name. */
        public static final String PROTOTYPE = "prototype";

        /**
         * Creates a payload map attempting prototype pollution.
         *
         * @return map containing the prototype pollution attempt
         */
        public static Map<String, Object> payload() {
            return Map.of("__proto__", Map.of("polluted", true));
        }
    }
}
