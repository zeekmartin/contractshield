import { RuleHit } from "../../types.js";

/**
 * Path traversal patterns including various encodings.
 * Order matters: more specific patterns first.
 */
const PATH_TRAVERSAL_PATTERNS = [
  // Standard patterns
  /\.\.\//g,                         // ../
  /\.\.\\/g,                         // ..\
  /\.\.$/,                           // .. at end

  // URL encoded
  /%2e%2e%2f/gi,                     // %2e%2e%2f = ../
  /%2e%2e\//gi,                      // %2e%2e/ = ../
  /%2e%2e%5c/gi,                     // %2e%2e%5c = ..\
  /%252e%252e%252f/gi,               // Double encoded

  // Unicode/overlong UTF-8
  /%c0%ae%c0%ae%c0%af/gi,            // Overlong UTF-8 for ../
  /%c0%ae%c0%ae\//gi,
  /\u002e\u002e\u002f/g,             // Unicode dots and slash

  // Null byte injection (can truncate paths)
  /%00/g,
  /\x00/g,
];

export interface PathTraversalOptions {
  /** Specific fields to check. If empty, scans all string values. */
  fields?: string[];
}

/**
 * Check for path traversal attack patterns in string values.
 * Detects ../ patterns in various encodings.
 *
 * @param data - The data to scan
 * @param options - Configuration for which fields to check
 * @returns Array of RuleHits if path traversal patterns found
 */
export function checkPathTraversal(data: unknown, options: PathTraversalOptions = {}): RuleHit[] {
  const hits: RuleHit[] = [];
  const violations: string[] = [];

  if (options.fields && options.fields.length > 0) {
    // Check specific fields only
    for (const field of options.fields) {
      const value = getNestedValue(data, field);
      if (typeof value === "string") {
        const violation = checkStringValue(value, field);
        if (violation) violations.push(violation);
      }
    }
  } else {
    // Scan all string values
    scanAllStrings(data, "", violations);
  }

  if (violations.length > 0) {
    hits.push({
      id: "vulnerability.pathTraversal",
      severity: "high",
      message: `Path traversal attempt detected: ${violations.join("; ")}`,
    });
  }

  return hits;
}

function scanAllStrings(obj: unknown, path: string, violations: string[]): void {
  if (obj === null || obj === undefined) return;

  if (typeof obj === "string") {
    const violation = checkStringValue(obj, path);
    if (violation) violations.push(violation);
    return;
  }

  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      scanAllStrings(obj[i], `${path}[${i}]`, violations);
    }
    return;
  }

  if (typeof obj === "object") {
    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;
      scanAllStrings(value, currentPath, violations);
    }
  }
}

function checkStringValue(value: string, path: string): string | null {
  // Skip very short strings (optimization)
  if (value.length < 2) return null;

  // Normalize: decode URL encoding for detection
  let normalized = value;
  try {
    // Decode once
    normalized = decodeURIComponent(value);
    // Decode twice for double-encoded attacks
    normalized = decodeURIComponent(normalized);
  } catch {
    // Invalid encoding, check original
    normalized = value;
  }

  // Check both original and normalized
  for (const pattern of PATH_TRAVERSAL_PATTERNS) {
    if (pattern.test(value) || pattern.test(normalized)) {
      return `${path}: "${truncate(value, 50)}"`;
    }
  }

  return null;
}

function truncate(str: string, maxLen: number): string {
  if (str.length <= maxLen) return str;
  return str.slice(0, maxLen) + "...";
}

function getNestedValue(obj: unknown, path: string): unknown {
  const parts = path.split(".").filter(Boolean);
  let current: unknown = obj;

  for (const part of parts) {
    if (current === null || current === undefined || typeof current !== "object") {
      return undefined;
    }
    current = (current as Record<string, unknown>)[part];
  }

  return current;
}
