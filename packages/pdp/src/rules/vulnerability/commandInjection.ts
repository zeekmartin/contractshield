import { RuleHit } from "../../types.js";

/**
 * Shell metacharacters that can be used for command injection.
 * Note: This check has potential for false positives with legitimate data.
 * Use field targeting for precise detection.
 */
const SHELL_METACHARACTERS = [
  ";",      // Command separator
  "|",      // Pipe
  "&",      // Background/AND
  "`",      // Command substitution (backtick)
  "$(",     // Command substitution (modern)
  "${",     // Variable expansion (can be abused)
  "$((",    // Arithmetic expansion
  "\n",     // Newline (command separator)
  "\r",     // Carriage return
  "&&",     // AND operator
  "||",     // OR operator
  ">>",     // Append redirect
  "<<",     // Here-document
  "<(",     // Process substitution
  ">(",     // Process substitution
];

/**
 * More aggressive patterns for command injection.
 * These have higher confidence but may still have false positives.
 */
const HIGH_CONFIDENCE_PATTERNS = [
  /;\s*\w+/,              // ; followed by command
  /\|\s*\w+/,             // | followed by command
  /`[^`]+`/,              // Backtick command substitution
  /\$\([^)]+\)/,          // $() command substitution
  /&&\s*\w+/,             // && followed by command
  /\|\|\s*\w+/,           // || followed by command
];

export interface CommandInjectionOptions {
  /** Specific fields to check. Required for this check to avoid false positives. */
  fields?: string[];
  /** Use high-confidence patterns only. Default: true */
  highConfidenceOnly?: boolean;
}

/**
 * Check for command injection patterns in string values.
 * This is an opt-in check due to potential false positives.
 *
 * @param data - The data to scan
 * @param options - Configuration for which fields to check
 * @returns Array of RuleHits if command injection patterns found
 */
export function checkCommandInjection(data: unknown, options: CommandInjectionOptions = {}): RuleHit[] {
  const hits: RuleHit[] = [];
  const violations: string[] = [];
  const highConfidenceOnly = options.highConfidenceOnly ?? true;

  if (options.fields && options.fields.length > 0) {
    // Check specific fields only (recommended)
    for (const field of options.fields) {
      const value = getNestedValue(data, field);
      if (typeof value === "string") {
        const violation = checkStringValue(value, field, highConfidenceOnly);
        if (violation) violations.push(violation);
      }
    }
  } else {
    // Scan all string values (higher false positive risk)
    scanAllStrings(data, "", violations, highConfidenceOnly);
  }

  if (violations.length > 0) {
    hits.push({
      id: "vulnerability.commandInjection",
      severity: "critical",
      message: `Command injection attempt detected: ${violations.join("; ")}`,
    });
  }

  return hits;
}

function scanAllStrings(obj: unknown, path: string, violations: string[], highConfidenceOnly: boolean): void {
  if (obj === null || obj === undefined) return;

  if (typeof obj === "string") {
    const violation = checkStringValue(obj, path, highConfidenceOnly);
    if (violation) violations.push(violation);
    return;
  }

  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      scanAllStrings(obj[i], `${path}[${i}]`, violations, highConfidenceOnly);
    }
    return;
  }

  if (typeof obj === "object") {
    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;
      scanAllStrings(value, currentPath, violations, highConfidenceOnly);
    }
  }
}

function checkStringValue(value: string, path: string, highConfidenceOnly: boolean): string | null {
  // Skip very short strings
  if (value.length < 2) return null;

  if (highConfidenceOnly) {
    // Use regex patterns with higher confidence
    for (const pattern of HIGH_CONFIDENCE_PATTERNS) {
      if (pattern.test(value)) {
        return `${path}: "${truncate(value, 40)}"`;
      }
    }
  } else {
    // Check for any shell metacharacter
    for (const char of SHELL_METACHARACTERS) {
      if (value.includes(char)) {
        return `${path}: contains "${char}"`;
      }
    }
  }

  return null;
}

function truncate(str: string, maxLen: number): string {
  if (str.length <= maxLen) return str;
  return str.slice(0, maxLen) + "...";
}

function getNestedValue(obj: unknown, path: string): unknown {
  const parts = path.split(".").filter(Boolean);
  let current: unknown = obj;

  for (const part of parts) {
    if (current === null || current === undefined || typeof current !== "object") {
      return undefined;
    }
    current = (current as Record<string, unknown>)[part];
  }

  return current;
}
