import { RuleHit } from "../../types.js";

/** Dangerous URL protocols that can be abused for SSRF. */
const DANGEROUS_PROTOCOLS = new Set(["file:", "gopher:", "dict:", "ftp:", "ldap:", "tftp:"]);

/** Private IP ranges (RFC 1918 + link-local + loopback + metadata). */
const PRIVATE_IP_PATTERNS = [
  /^127\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,           // Loopback
  /^10\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,            // Class A private
  /^172\.(1[6-9]|2\d|3[0-1])\.\d{1,3}\.\d{1,3}$/, // Class B private
  /^192\.168\.\d{1,3}\.\d{1,3}$/,               // Class C private
  /^169\.254\.\d{1,3}\.\d{1,3}$/,               // Link-local
  /^0\.0\.0\.0$/,                                // Any interface
  /^::1$/,                                       // IPv6 loopback
  /^fc00:/i,                                     // IPv6 unique local
  /^fe80:/i,                                     // IPv6 link-local
];

const DANGEROUS_HOSTNAMES = new Set([
  "localhost",
  "127.0.0.1",
  "0.0.0.0",
  "::1",
  "[::1]",
  "metadata.google.internal",          // GCP metadata
  "169.254.169.254",                   // AWS/Azure/GCP metadata
  "metadata.internal",
]);

export interface SsrfCheckOptions {
  /** Specific fields to check. If empty, scans all string values. */
  fields?: string[];
}

/**
 * Check for SSRF vulnerabilities in URL-like string values.
 * Detects internal IPs, dangerous protocols, and cloud metadata endpoints.
 *
 * @param data - The data to scan
 * @param options - Configuration for which fields to check
 * @returns Array of RuleHits if SSRF patterns found
 */
export function checkSsrfInternal(data: unknown, options: SsrfCheckOptions = {}): RuleHit[] {
  const hits: RuleHit[] = [];
  const violations: string[] = [];

  if (options.fields && options.fields.length > 0) {
    // Check specific fields only
    for (const field of options.fields) {
      const value = getNestedValue(data, field);
      if (typeof value === "string") {
        const violation = checkUrlValue(value, field);
        if (violation) violations.push(violation);
      }
    }
  } else {
    // Scan all string values
    scanAllStrings(data, "", violations);
  }

  if (violations.length > 0) {
    hits.push({
      id: "vulnerability.ssrfInternal",
      severity: "critical",
      message: `SSRF attempt detected: ${violations.join("; ")}`,
    });
  }

  return hits;
}

function scanAllStrings(obj: unknown, path: string, violations: string[]): void {
  if (obj === null || obj === undefined) return;

  if (typeof obj === "string") {
    const violation = checkUrlValue(obj, path);
    if (violation) violations.push(violation);
    return;
  }

  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      scanAllStrings(obj[i], `${path}[${i}]`, violations);
    }
    return;
  }

  if (typeof obj === "object") {
    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;
      scanAllStrings(value, currentPath, violations);
    }
  }
}

function checkUrlValue(value: string, path: string): string | null {
  // Quick check: skip non-URL-like strings
  if (!value.includes("://") && !value.includes("//") && !value.startsWith("/")) {
    return null;
  }

  try {
    // Try parsing as URL (handles both absolute and protocol-relative)
    const urlStr = value.startsWith("//") ? `http:${value}` : value;
    const url = new URL(urlStr);

    // Check dangerous protocols
    if (DANGEROUS_PROTOCOLS.has(url.protocol)) {
      return `${path}: dangerous protocol "${url.protocol}"`;
    }

    // Check hostname
    const hostname = url.hostname.toLowerCase();

    if (DANGEROUS_HOSTNAMES.has(hostname)) {
      return `${path}: internal hostname "${hostname}"`;
    }

    // Check if hostname is a private IP
    if (isPrivateIP(hostname)) {
      return `${path}: private IP "${hostname}"`;
    }

    // Check for DNS rebinding attempts with numeric IPs
    const ipMatch = hostname.match(/^\d+$/);
    if (ipMatch) {
      // Decimal IP notation (e.g., 2130706433 = 127.0.0.1)
      return `${path}: suspicious decimal IP notation`;
    }

  } catch {
    // Not a valid URL, check for path traversal patterns that might indicate SSRF
    if (value.match(/^\/\/\d+\.\d+\.\d+\.\d+/)) {
      return `${path}: protocol-relative URL with IP`;
    }
  }

  return null;
}

function isPrivateIP(hostname: string): boolean {
  for (const pattern of PRIVATE_IP_PATTERNS) {
    if (pattern.test(hostname)) {
      return true;
    }
  }
  return false;
}

function getNestedValue(obj: unknown, path: string): unknown {
  const parts = path.split(".").filter(Boolean);
  let current: unknown = obj;

  for (const part of parts) {
    if (current === null || current === undefined || typeof current !== "object") {
      return undefined;
    }
    current = (current as Record<string, unknown>)[part];
  }

  return current;
}
